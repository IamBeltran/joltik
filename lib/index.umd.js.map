{"version":3,"file":"index.umd.js","sources":["../src/index.js"],"sourcesContent":["/**\n * joltik's JSX pragma\n * @param {*} type\n * @param {*} props\n * @param  {...any} args\n */\nexport function j(type, props, ...args) {\n  const children = args.length ? [].concat(...args) : null;\n  return {\n    type,\n    props: props || {},\n    children\n  };\n}\n\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n\nfunction setProp(node, name, value) {\n  if (name === \"className\") {\n    name = \"class\";\n  } else if (typeof value === \"boolean\") {\n    setBooleanProp(node, name, value);\n  }\n\n  node.setAttribute(name, value);\n}\n\nfunction setBooleanProp(node, name, value) {\n  if (value) {\n    node.setAttribute(name, value);\n    node[name] = true;\n  } else {\n    node[name] = false;\n  }\n}\n\nfunction setAttributes(node, props = {}) {\n  if (!props) {\n    return;\n  }\n  Object.keys(props)\n    .filter(prop => !isEventProp(prop))\n    .forEach(name => setProp(node, name, props[name]));\n}\n\nfunction addEventListeners(node, props = {}) {\n  if (!props) {\n    return;\n  }\n  Object.keys(props)\n    .filter(isEventProp)\n    .forEach(event =>\n      node.addEventListener(extractEventName(event), props[event])\n    );\n}\n\n/**\n * Creates a DOM node.\n * @param {*} node\n */\nexport function createElement(node) {\n  // Text nodes can be created stright away, and can't have children or attributes.\n  if (typeof node === \"string\") {\n    return document.createTextNode(node);\n  }\n\n  // Object nodes are new tags, and it needs to be considered a new element.\n  // the function uses recursion to parse this object.\n  if (typeof node.type === \"object\") {\n    return createElement(node.type);\n  }\n\n  // A functional component is parameterized. It just needs\n  // to call the function with the props as the arguments.\n  if (typeof node.type === \"function\") {\n    return createElement(node.type(node.props));\n  }\n\n  const element = document.createElement(node.type);\n\n  // Sets the element attributes\n  setAttributes(element, node.props);\n\n  // Event listeners are threated independently\n  addEventListeners(element, node.props);\n\n  // Uses recursion to render its children, if any\n  node.children &&\n    node.children\n      .map(createElement)\n      .forEach(child => element.appendChild(child));\n\n  return element;\n}\n\n/**\n * Updates a DOM node.\n * @param {*} parentNode\n * @param {*} newNode\n * @param {*} oldNode\n * @param {*} index\n */\nexport function updateElement(parentNode, newNode, oldNode, index = 0) {\n  // If the old node doesn't exist, it adds the new one to the parent.\n  if (!oldNode) {\n    parentNode.appendChild(createElement(newNode));\n    // If the new node doesn't exist, it removes it from the parent.\n  } else if (!newNode) {\n    parentNode.removeChild(parentNode.childNodes[index]);\n    // If the nodes have changed, it replaces the old one with its new version.\n  } else if (nodesAreDifferent(newNode, oldNode)) {\n    parentNode.replaceChild(\n      createElement(newNode),\n      parentNode.childNodes[index]\n    );\n  } else if (newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n\n    // Recursively updates its children\n    for (let i = 0; i < newLength || i < oldLength; i++) {\n      updateElement(\n        parentNode.childNodes[index],\n        newNode.children[i],\n        oldNode.children[i],\n        i\n      );\n    }\n  }\n}\n\n/**\n * Compares two DOM nodes to decide if they are different.\n * @param {*} first\n * @param {*} second\n */\nfunction nodesAreDifferent(first, second) {\n  return (\n    typeof first !== typeof second ||\n    (typeof first === \"string\" && first !== second) ||\n    first.type !== second.type\n  );\n}\n"],"names":["isEventProp","name","test","createElement","node","document","createTextNode","type","props","element","Object","keys","filter","prop","forEach","value","setAttribute","setBooleanProp","setProp","setAttributes","event","addEventListener","slice","toLowerCase","addEventListeners","children","map","child","appendChild","args","length","concat","ref","updateElement","parentNode","newNode","oldNode","index","first","second","replaceChild","childNodes","newLength","oldLength","i","removeChild"],"mappings":"4KAeA,SAASA,EAAYC,SACZ,MAAMC,KAAKD,GAkDb,SAASE,EAAcC,MAER,iBAATA,SACFC,SAASC,eAAeF,MAKR,iBAAdA,EAAKG,YACPJ,EAAcC,EAAKG,SAKH,mBAAdH,EAAKG,YACPJ,EAAcC,EAAKG,KAAKH,EAAKI,YAGhCC,EAAUJ,SAASF,cAAcC,EAAKG,aA1C9C,SAAuBH,EAAMI,kBAAQ,IAC9BA,GAGLE,OAAOC,KAAKH,GACTI,gBAAOC,UAASb,EAAYa,KAC5BC,iBAAQb,UAzBb,SAAiBG,EAAMH,EAAMc,GACd,cAATd,EACFA,EAAO,QACmB,kBAAVc,GAOpB,SAAwBX,EAAMH,EAAMc,GAC9BA,GACFX,EAAKY,aAAaf,EAAMc,GACxBX,EAAKH,IAAQ,GAEbG,EAAKH,IAAQ,EAXbgB,CAAeb,EAAMH,EAAMc,GAG7BX,EAAKY,aAAaf,EAAMc,GAkBLG,CAAQd,EAAMH,EAAMO,EAAMP,MAuC7CkB,CAAcV,EAASL,EAAKI,OApC9B,SAA2BJ,EAAMI,kBAAQ,IAClCA,GAGLE,OAAOC,KAAKH,GACTI,OAAOZ,GACPc,iBAAQM,UACPhB,EAAKiB,iBAAkCD,EAtC/BE,MAAM,GAAGC,cAsC8Bf,EAAMY,MAgCzDI,CAAkBf,EAASL,EAAKI,OAGhCJ,EAAKqB,UACHrB,EAAKqB,SACFC,IAAIvB,GACJW,iBAAQa,UAASlB,EAAQmB,YAAYD,KAEnClB,MA5FF,SAAWF,EAAMC,yEAEf,MACLD,EACAC,MAAOA,GAAS,YAHDqB,EAAKC,UAAS,IAAGC,aAAOC,EAAGH,GAAQ,yCAqG/C,SAASI,EAAcC,EAAYC,EAASC,EAASC,qBAAQ,GAE7DD,EAGE,GAAKD,GAGL,UA0BkBG,EA1BIH,WA0BGI,EA1BMH,IA6BlB,iBAAVE,GAAsBA,IAAUC,GACxCD,EAAM/B,OAASgC,EAAOhC,KA7BtB2B,EAAWM,aACTrC,EAAcgC,GACdD,EAAWO,WAAWJ,SAEnB,GAAIF,EAAQ5B,aACXmC,EAAYP,EAAQV,SAASK,OAC7Ba,EAAYP,EAAQX,SAASK,OAG1Bc,EAAI,EAAGA,EAAIF,GAAaE,EAAID,EAAWC,IAC9CX,EACEC,EAAWO,WAAWJ,GACtBF,EAAQV,SAASmB,GACjBR,EAAQX,SAASmB,GACjBA,QAjBJV,EAAWW,YAAYX,EAAWO,WAAWJ,SAH7CH,EAAWN,YAAYzB,EAAcgC,IA+BzC,IAA2BG,EAAOC"}