{"version":3,"file":"index.mjs","sources":["../src/index.js"],"sourcesContent":["/**\n * joltik's JSX pragma\n * @param {*} type\n * @param {*} props\n * @param  {...any} args\n */\nexport function j(type, props, ...args) {\n  const children = args.length ? [].concat(...args) : null;\n  return {\n    type,\n    props: props || {},\n    children\n  };\n}\n\nfunction isEventProp(name) {\n  return /^on/.test(name);\n}\n\nfunction extractEventName(name) {\n  return name.slice(2).toLowerCase();\n}\n\nfunction setProp(node, name, value) {\n  if (name === \"className\") {\n    name = \"class\";\n  } else if (typeof value === \"boolean\") {\n    setBooleanProp(node, name, value);\n  }\n\n  node.setAttribute(name, value);\n}\n\nfunction setBooleanProp(node, name, value) {\n  if (value) {\n    node.setAttribute(name, value);\n    node[name] = true;\n  } else {\n    node[name] = false;\n  }\n}\n\nfunction setAttributes(node, props = {}) {\n  if (!props) {\n    return;\n  }\n  Object.keys(props)\n    .filter(prop => !isEventProp(prop))\n    .forEach(name => setProp(node, name, props[name]));\n}\n\nfunction addEventListeners(node, props = {}) {\n  if (!props) {\n    return;\n  }\n  Object.keys(props)\n    .filter(isEventProp)\n    .forEach(event =>\n      node.addEventListener(extractEventName(event), props[event])\n    );\n}\n\n/**\n * Creates a DOM node.\n * @param {*} node\n */\nexport function createElement(node) {\n  // Text nodes can be created stright away, and can't have children or attributes.\n  if (typeof node === \"string\") {\n    return document.createTextNode(node);\n  }\n\n  // Object nodes are new tags, and it needs to be considered a new element.\n  // the function uses recursion to parse this object.\n  if (typeof node.type === \"object\") {\n    return createElement(node.type);\n  }\n\n  // A functional component is parameterized. It just needs\n  // to call the function with the props as the arguments.\n  if (typeof node.type === \"function\") {\n    return createElement(node.type(node.props));\n  }\n\n  const element = document.createElement(node.type);\n\n  // Sets the element attributes\n  setAttributes(element, node.props);\n\n  // Event listeners are threated independently\n  addEventListeners(element, node.props);\n\n  // Uses recursion to render its children, if any\n  node.children &&\n    node.children\n      .map(createElement)\n      .forEach(child => element.appendChild(child));\n\n  return element;\n}\n\n/**\n * Updates a DOM node.\n * @param {*} parentNode\n * @param {*} newNode\n * @param {*} oldNode\n * @param {*} index\n */\nexport function updateElement(parentNode, newNode, oldNode, index = 0) {\n  // If the old node doesn't exist, it adds the new one to the parent.\n  if (!oldNode) {\n    parentNode.appendChild(createElement(newNode));\n    // If the new node doesn't exist, it removes it from the parent.\n  } else if (!newNode) {\n    parentNode.removeChild(parentNode.childNodes[index]);\n    // If the nodes have changed, it replaces the old one with its new version.\n  } else if (nodesAreDifferent(newNode, oldNode)) {\n    parentNode.replaceChild(\n      createElement(newNode),\n      parentNode.childNodes[index]\n    );\n  } else if (newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n\n    // Recursively updates its children\n    for (let i = 0; i < newLength || i < oldLength; i++) {\n      updateElement(\n        parentNode.childNodes[index],\n        newNode.children[i],\n        oldNode.children[i],\n        i\n      );\n    }\n  }\n}\n\n/**\n * Compares two DOM nodes to decide if they are different.\n * @param {*} first\n * @param {*} second\n */\nfunction nodesAreDifferent(first, second) {\n  return (\n    typeof first !== typeof second ||\n    (typeof first === \"string\" && first !== second) ||\n    first.type !== second.type\n  );\n}\n"],"names":["j","type","props","args","length","concat","ref","isEventProp","name","test","createElement","node","document","createTextNode","element","Object","keys","filter","prop","forEach","value","setAttribute","setBooleanProp","setProp","setAttributes","event","addEventListener","slice","toLowerCase","addEventListeners","children","map","child","appendChild","updateElement","parentNode","newNode","oldNode","index","first","second","replaceChild","childNodes","newLength","oldLength","i","removeChild"],"mappings":"AAMO,SAASA,EAAEC,EAAMC,yEAEf,MACLD,EACAC,MAAOA,GAAS,YAHDC,EAAKC,UAAS,IAAGC,aAAOC,EAAGH,GAAQ,MAQtD,SAASI,EAAYC,SACZ,MAAMC,KAAKD,GAkDb,SAASE,EAAcC,MAER,iBAATA,SACFC,SAASC,eAAeF,MAKR,iBAAdA,EAAKV,YACPS,EAAcC,EAAKV,SAKH,mBAAdU,EAAKV,YACPS,EAAcC,EAAKV,KAAKU,EAAKT,YAGhCY,EAAUF,SAASF,cAAcC,EAAKV,aA1C9C,SAAuBU,EAAMT,kBAAQ,IAC9BA,GAGLa,OAAOC,KAAKd,GACTe,gBAAOC,UAASX,EAAYW,KAC5BC,iBAAQX,UAzBb,SAAiBG,EAAMH,EAAMY,GACd,cAATZ,EACFA,EAAO,QACmB,kBAAVY,GAOpB,SAAwBT,EAAMH,EAAMY,GAC9BA,GACFT,EAAKU,aAAab,EAAMY,GACxBT,EAAKH,IAAQ,GAEbG,EAAKH,IAAQ,EAXbc,CAAeX,EAAMH,EAAMY,GAG7BT,EAAKU,aAAab,EAAMY,GAkBLG,CAAQZ,EAAMH,EAAMN,EAAMM,MAuC7CgB,CAAcV,EAASH,EAAKT,OApC9B,SAA2BS,EAAMT,kBAAQ,IAClCA,GAGLa,OAAOC,KAAKd,GACTe,OAAOV,GACPY,iBAAQM,UACPd,EAAKe,iBAAkCD,EAtC/BE,MAAM,GAAGC,cAsC8B1B,EAAMuB,MAgCzDI,CAAkBf,EAASH,EAAKT,OAGhCS,EAAKmB,UACHnB,EAAKmB,SACFC,IAAIrB,GACJS,iBAAQa,UAASlB,EAAQmB,YAAYD,KAEnClB,EAUT,SAAgBoB,EAAcC,EAAYC,EAASC,EAASC,qBAAQ,GAE7DD,EAGE,GAAKD,GAGL,UA0BkBG,EA1BIH,WA0BGI,EA1BMH,IA6BlB,iBAAVE,GAAsBA,IAAUC,GACxCD,EAAMtC,OAASuC,EAAOvC,KA7BtBkC,EAAWM,aACT/B,EAAc0B,GACdD,EAAWO,WAAWJ,SAEnB,GAAIF,EAAQnC,aACX0C,EAAYP,EAAQN,SAAS1B,OAC7BwC,EAAYP,EAAQP,SAAS1B,OAG1ByC,EAAI,EAAGA,EAAIF,GAAaE,EAAID,EAAWC,IAC9CX,EACEC,EAAWO,WAAWJ,GACtBF,EAAQN,SAASe,GACjBR,EAAQP,SAASe,GACjBA,QAjBJV,EAAWW,YAAYX,EAAWO,WAAWJ,SAH7CH,EAAWF,YAAYvB,EAAc0B,IA+BzC,IAA2BG,EAAOC"}